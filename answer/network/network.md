# 网络 面试题

## 目录

- [1. 介绍下场景 http 状态码](#1)
- [2. 谈谈 HTTP 中 GET 与 POST 的区别](#2)
- [3. HTTP/1.0 和 HTTP/1.1 有什么区别](#3)
- [4. 介绍一下 HTTP/2.0 新特性](#4)
- [5. 说说 HTTP/2.0 多路复用的基本原理以及解决的问题](#5)
- [6. HTTP 和 HTTPS 有何区别](#6)
- [7. 什么是 CSRF 攻击，与如何防范。](#7)
- [8. 什么是 XSS 攻击，如何防御。](#8)
- [9. 在项目中如何把 http 的请求换成 https](#9)

## 题解

#### <a href="#1" id="1">1. 介绍下场景 http 状态码</a>

1xx: 1 开头的是信息状态码

2xx: 2 开头的是请求成功

> 200 服务器已经成功处理请求，并提供了请求的网页  
> 201 用户新建或修改数据成功  
> 202 已接收  
> 204 用户删除成功

3xx: 3 开头的是重定向

> 301： 永久移动，重定向  
> 302：临时移动，可使用原有 URI  
> 304：资源未修改，可使用缓存  
> 305：需代理访问

4xx：4 开头是客户端错误

> 400 请求语法错误  
> 401 用户没有权限，要求身份认证  
> 403 拒绝请求  
> 404 资源不存在

5xx：5 开头的是服务器错误

> 500 服务器错误，无法完成请求  
> 503 服务器目前无法使用（超载或停机维护）


<br>
<br>

#### <a href="#2" id="2">2. 谈谈 HTTP 中 GET 与 POST 的区别</a>

1. GET 使用 URL 或 cookie 传参，而 POST 将数据放在 BODY 中， 这个是因为 HTTP 协议用法的约定，并非他们的本身区别

2. GET 方式提交的数据有长度限制，而 POST 的数据则可以非常大，这是因为浏览器限制了 GET 请求的长度

3. POST 比 GET 安全，因为 GET 提交的数据，会被浏览器历史记录缓存下来

<br>
<br>

#### <a href="#3" id="3">3. HTTP/1.0 和 HTTP/1.1 有什么区别</a>

1. **长连接**：HTTP/1.1 支持场链接和请求的流水线，在一个 TCP 连接上可以传送多个 HTTP 请求，避免了因为多次建立 TCP 连接的时间消耗和延时
2. **缓存处理**：HTTP/1.1 引入了 `Entity tag, IF-Unmodified-Since, If-Match, If-None-Match`等新的请求头来控制缓存
3. **带宽优化及网络连接的使用**：HTTP/1.1 在请求头引入了 range ，支持断点续传功能
4. **Host 头处理**：在 HTTP/1.0 中认为每台服务器都有唯一的 IP 地址，但随着虚拟主机技术的发展，多个主机共享一个 IP 地址愈发普片，HTTP 1.1 的请求消息和响应消息都应该支持 Host 头域，且请求消息中如果没有 Host 头域会 400 错误。

<br>
<br>

#### <a href="#4" id="4">4. 介绍一下 HTTP/2.0 新特性</a>

1. **多路复用**：即多个请求都通过一个 TCP 连接并发地完成
2. **服务端推送**：服务端能够主动把资源推送给客户端
3. **新的二进制格式**：HTTP/2 采用二进制格式传输数据，相比于 HTTP/1.1 的文本格式，二进制格式具有更好的解析性和拓展性
4. **header 压缩**：HTTP/2 压缩消息头，减少了传输数据的大小

<br>
<br>

#### <a href="#5" id="5">5. 说说 HTTP/2.0 多路复用的基本原理以及解决的问题</a>

HTTP/2 解决的问题，就是 HTTP/1.1 存在的问题：

1. **TCP 慢启动**：TCP 连接建立后，会经历一个先慢后快的发送过程，如果我们的资源都经过一次慢启动，对性能是不小的损耗。另外慢启动是 TCP 为了减少网络拥塞的一种策略，我们是没有办法改变的。
2. **多条 TCP 连接竞争带宽**：如果同时建立多条 TCP 连接，当带宽不足时就会竞争带宽，影响关键资源的下载。
3. **HTTP/1.1 队头阻塞**：尽管 HTTP/1.1 长连接可以通过一个 TCP 连接传输多个请求，但同一时刻只能处理一个请求，当前请求未结束前，其他请求只能处于阻塞状态。

为了解决以上的问题，**HTTP/2 一个域名只能使用一个 TCP 长连接来传输数据，而且请求之间是并行的、非阻塞的，这就是多路复用。**

**实现原理**：HTTP/2 引入了一个二进制分帧层，客户端和服务端进行传输时，数据会先经过二进制分帧层处理，转化为一个个带有请求 ID 的帧，这些帧在传输完成后根据 ID 组合对应的数据。

<br>
<br>

#### <a href="#6" id="6">6. HTTP 和 HTTPS 有何区别</a>

1. HTTPS 使用 443 端口，而 HTTP 使用 80
2. HTTPS 需要申请证书
3. HTTP 是超文本传输协议，是明文传输；HTTPS 是经过 SSL 加密的协议，传输更安全
4. HTTPS 比 HTTP 慢，因为 HTTPS 除了 TCP 握手的三个包，还要加上 SSL 握手的九个包

<br>
<br>

#### <a href="#7" id="7">7. 什么是 CSRF 攻击，与如何防范。</a>

CSRF 即 Cross-site request forgery（跨站请求伪造），是一种挟持用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法

加入黑客在自己的站点上放置了其他网站的外链，默认情况下，黑客网站静默调用其他网站的接口时，浏览器会待着对应网站的 cookie 访问这个网址，如果用户已登录过该网站且网站没有对 CSRF 进行防御，那么服务器就会认为是用户本人在调用此接口并执行相关操作，致使账号被劫持。

##### 如何防御 CSRF 攻击

- 验证 Token ：浏览器请求服务器时，服务器返回一个 token，每个请求都需要同时带上 token 和 cookie 才会被认为是合法请求
- 验证 Referer：通过验证请求头的 Referer 来验证来源站点，但请求头很容易伪造
- 设置 SameSite：设置 cookie 的 SameSite，可以让 cookie 不随跨域请求发出，但浏览器兼容不一

<br>
<br>

#### <a href="#8" id="8">8. 什么是 XSS 攻击，如何防御。</a>

XSS 即 Cross-site Scripting（跨站脚本），指的是利用网页开发时留下的漏铜，注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。常见的例如在评论区植入 JS 代码，用户进入评论页时代码被执行，造成页面被植入广告、账号信息被窃取

##### XSS 攻击有哪些类型

- **存储型**：即攻击被存储在服务端，常见的是在评论区插入攻击脚本，如果脚本被存储到服务端，那么所有看见对应评论的用户都会受到攻击
- **反射性**：攻击者将脚本混在 URL 里，服务端接收到 URL ，将恶意代码当做参数去除并拼接在 HTML 里返回，浏览器解析此 HTML 后即执行恶意代码
- **DOM 型**：将攻击脚本写在 URL 中，诱导用户点击该 URL，如果 URL 被解析，那么攻击脚本就会被运行。

##### 如何防御 XSS 攻击

- **输入检查**：对输入内容中的标签进行转义或过滤
- **设置 httpOnly**：很多 XSS 攻击目标都是窃取用户 cookie 伪造身份认证，设置此属性可防止 JS 获取 cookie
- **开启 CSP**，即开启白名单，可组织白名单以外的资源加载和运行。

<br>
<br>

#### <a href="#9" id="9">9. 在项目中如何把 http 的请求换成 https</a>

1. 在请求库发送之前做一层 baseURL 封装，正则替换掉

2. 使用 `meta` 标签自动预检

   ```html
   <meta http-equiv="Content-Security-Policy" 
         content="upgrade-insecure-requests" />
   ```

   关键在`upgrade-insecure-requests`，服务器在收到请求后会返回 `Content-Security-Policy: upgrade-insecure-requests` 头，告诉浏览器，可以把所属本站的所有 http 连接升级为 https 连接。

   注意：

   - 升级后的链接在服务器端必须有对应的资源
   - 只会升级网站内部的链接，对于不属于网站同部的链接，保持默认状态
   - 有兼容性问题

3. Nginx 好像可以配置，不懂...

