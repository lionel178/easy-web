# 网络 面试题

## 目录

- [1. 介绍下场景 http 状态码](#1)
- [2. 谈谈 HTTP 中 GET 与 POST 的区别](#2)
- [3. HTTP/1.0 和 HTTP/1.1 有什么区别](#3)
- [4. 介绍一下 HTTP/2.0 新特性](#4)
- [5. 说说 HTTP/2.0 多路复用的基本原理以及解决的问题](#5)
- [6. HTTP 和 HTTPS 有何区别](#6)
- [7. 什么是 CSRF 攻击，与如何防范。](#7)
- [8. 什么是 XSS 攻击，如何防御。](#8)
- [9. 在项目中如何把 http 的请求换成 https](#9)
- [10. DNS 解析的具体过程](#10)
- [11. 说一下 TCP 三次握手过程](#11)
- [12. 说一下 TCP 四次挥手过程](#12)
- [13. 介绍一下对称加密和非对称加密](#13)
- [14. 为什么 TCP 建立连接需要三次握手，而不是两次](#14)
- [15. https 的握手过程](#15)
- [16. CDN 是什么？描述下 CDN 原理？为什么要用 CDN?](#16)
- [17. 说一下正向代理和反向代理](#17)

## 题解

#### <a href="#1" id="1">1. 介绍下场景 http 状态码</a>

1xx: 1 开头的是信息状态码

2xx: 2 开头的是请求成功

> 200 服务器已经成功处理请求，并提供了请求的网页  
> 201 用户新建或修改数据成功  
> 202 已接收  
> 204 用户删除成功

3xx: 3 开头的是重定向

> 301： 永久移动，重定向  
> 302：临时移动，可使用原有 URI  
> 304：资源未修改，可使用缓存  
> 305：需代理访问

4xx：4 开头是客户端错误

> 400 请求语法错误  
> 401 用户没有权限，要求身份认证  
> 403 拒绝请求  
> 404 资源不存在

5xx：5 开头的是服务器错误

> 500 服务器错误，无法完成请求  
> 503 服务器目前无法使用（超载或停机维护）

<br>
<br>

#### <a href="#2" id="2">2. 谈谈 HTTP 中 GET 与 POST 的区别</a>

1. GET 使用 URL 或 cookie 传参，而 POST 将数据放在 BODY 中， 这个是因为 HTTP 协议用法的约定，并非他们的本身区别

2. GET 方式提交的数据有长度限制，而 POST 的数据则可以非常大，这是因为浏览器限制了 GET 请求的长度

3. POST 比 GET 安全，因为 GET 提交的数据，会被浏览器历史记录缓存下来

<br>
<br>

#### <a href="#3" id="3">3. HTTP/1.0 和 HTTP/1.1 有什么区别</a>

1. **长连接**：HTTP/1.1 支持场链接和请求的流水线，在一个 TCP 连接上可以传送多个 HTTP 请求，避免了因为多次建立 TCP 连接的时间消耗和延时
2. **缓存处理**：HTTP/1.1 引入了 `Entity tag, IF-Unmodified-Since, If-Match, If-None-Match`等新的请求头来控制缓存
3. **带宽优化及网络连接的使用**：HTTP/1.1 在请求头引入了 range ，支持断点续传功能
4. **Host 头处理**：在 HTTP/1.0 中认为每台服务器都有唯一的 IP 地址，但随着虚拟主机技术的发展，多个主机共享一个 IP 地址愈发普片，HTTP 1.1 的请求消息和响应消息都应该支持 Host 头域，且请求消息中如果没有 Host 头域会 400 错误。

<br>
<br>

#### <a href="#4" id="4">4. 介绍一下 HTTP/2.0 新特性</a>

1. **多路复用**：即多个请求都通过一个 TCP 连接并发地完成
2. **服务端推送**：服务端能够主动把资源推送给客户端
3. **新的二进制格式**：HTTP/2 采用二进制格式传输数据，相比于 HTTP/1.1 的文本格式，二进制格式具有更好的解析性和拓展性
4. **header 压缩**：HTTP/2 压缩消息头，减少了传输数据的大小

<br>
<br>

#### <a href="#5" id="5">5. 说说 HTTP/2.0 多路复用的基本原理以及解决的问题</a>

HTTP/2 解决的问题，就是 HTTP/1.1 存在的问题：

1. **TCP 慢启动**：TCP 连接建立后，会经历一个先慢后快的发送过程，如果我们的资源都经过一次慢启动，对性能是不小的损耗。另外慢启动是 TCP 为了减少网络拥塞的一种策略，我们是没有办法改变的。
2. **多条 TCP 连接竞争带宽**：如果同时建立多条 TCP 连接，当带宽不足时就会竞争带宽，影响关键资源的下载。
3. **HTTP/1.1 队头阻塞**：尽管 HTTP/1.1 长连接可以通过一个 TCP 连接传输多个请求，但同一时刻只能处理一个请求，当前请求未结束前，其他请求只能处于阻塞状态。

为了解决以上的问题，**HTTP/2 一个域名只能使用一个 TCP 长连接来传输数据，而且请求之间是并行的、非阻塞的，这就是多路复用。**

**实现原理**：HTTP/2 引入了一个二进制分帧层，客户端和服务端进行传输时，数据会先经过二进制分帧层处理，转化为一个个带有请求 ID 的帧，这些帧在传输完成后根据 ID 组合对应的数据。

<br>
<br>

#### <a href="#6" id="6">6. HTTP 和 HTTPS 有何区别</a>

1. HTTPS 使用 443 端口，而 HTTP 使用 80
2. HTTPS 需要申请证书
3. HTTP 是超文本传输协议，是明文传输；HTTPS 是经过 SSL 加密的协议，传输更安全
4. HTTPS 比 HTTP 慢，因为 HTTPS 除了 TCP 握手的三个包，还要加上 SSL 握手的九个包

<br>
<br>

#### <a href="#7" id="7">7. 什么是 CSRF 攻击，与如何防范。</a>

CSRF 即 Cross-site request forgery（跨站请求伪造），是一种挟持用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法

加入黑客在自己的站点上放置了其他网站的外链，默认情况下，黑客网站静默调用其他网站的接口时，浏览器会待着对应网站的 cookie 访问这个网址，如果用户已登录过该网站且网站没有对 CSRF 进行防御，那么服务器就会认为是用户本人在调用此接口并执行相关操作，致使账号被劫持。

##### 如何防御 CSRF 攻击

- 验证 Token ：浏览器请求服务器时，服务器返回一个 token，每个请求都需要同时带上 token 和 cookie 才会被认为是合法请求
- 验证 Referer：通过验证请求头的 Referer 来验证来源站点，但请求头很容易伪造
- 设置 SameSite：设置 cookie 的 SameSite，可以让 cookie 不随跨域请求发出，但浏览器兼容不一

<br>
<br>

#### <a href="#8" id="8">8. 什么是 XSS 攻击，如何防御。</a>

XSS 即 Cross-site Scripting（跨站脚本），指的是利用网页开发时留下的漏铜，注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。常见的例如在评论区植入 JS 代码，用户进入评论页时代码被执行，造成页面被植入广告、账号信息被窃取

##### XSS 攻击有哪些类型

- **存储型**：即攻击被存储在服务端，常见的是在评论区插入攻击脚本，如果脚本被存储到服务端，那么所有看见对应评论的用户都会受到攻击
- **反射性**：攻击者将脚本混在 URL 里，服务端接收到 URL ，将恶意代码当做参数去除并拼接在 HTML 里返回，浏览器解析此 HTML 后即执行恶意代码
- **DOM 型**：将攻击脚本写在 URL 中，诱导用户点击该 URL，如果 URL 被解析，那么攻击脚本就会被运行。

##### 如何防御 XSS 攻击

- **输入检查**：对输入内容中的标签进行转义或过滤
- **设置 httpOnly**：很多 XSS 攻击目标都是窃取用户 cookie 伪造身份认证，设置此属性可防止 JS 获取 cookie
- **开启 CSP**，即开启白名单，可组织白名单以外的资源加载和运行。

<br>
<br>

#### <a href="#9" id="9">9. 在项目中如何把 http 的请求换成 https</a>

1. 在请求库发送之前做一层 baseURL 封装，正则替换掉

2. 使用 `meta` 标签自动预检

   ```html
   <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests" />
   ```

   关键在`upgrade-insecure-requests`，服务器在收到请求后会返回 `Content-Security-Policy: upgrade-insecure-requests` 头，告诉浏览器，可以把所属本站的所有 http 连接升级为 https 连接。

   注意：

   - 升级后的链接在服务器端必须有对应的资源
   - 只会升级网站内部的链接，对于不属于网站同部的链接，保持默认状态
   - 有兼容性问题

3. Nginx 好像可以配置，不懂...

<br/>
<br/>

#### <a href="#10" id="10">10. DNS 解析的具体过程</a>

1. 检查浏览器缓存中是否缓存过该域名对应的 IP 地址

2. 如果浏览器缓存中没有命中，将继续查找本机（操作系统）是否缓存过该 IP
3. 向本地域名解析服务系统发起域名解析的请求（一般是本地运营商的机房）
4. 向根域名解析服务器发起域名解析请求
5. 根域名服务器返回 gTLD 域名解析服务器地址
6. 向 gTLD 服务器发起解析请求
7. gTLD 服务器接收请求并返回 Name Server 服务器（通常情况下就是你注册的域名服务器）
8. Name Server 服务器返回 IP 地址给本地服务器
9. 本地域名服务器缓存解析结果
10. 返回解析结果给用户

<br/>
<br/>

#### <a href="#11" id="11">11. 说一下 TCP 三次握手过程</a>

1. 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端进入 SYN-SENT 状态

2. 服务端接收到客户端请求，发送应答，应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。

3. 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTSBLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。

<br/>
<br/>

#### <a href="#12" id="12">12. 说一下 TCP 四次挥手过程</a>

1. 若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。

2. B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接时双向的，所以 B 仍旧可以发送数据给 A

3. B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。

4. A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃）时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。

<br/>
<br/>

#### <a href="#13" id="13">13. 介绍一下对称加密和非对称加密</a>

##### 对称加密的过程：

1. A 生成一份密钥，通过互联网发给 B
2. A 生成明文，使用密钥加密，发送给 B
3. B 使用密钥解密

##### 对称加密优缺点

优点：算法公开、计算量小、加密速度快、加密效率高  
缺点：在数据传送前，发送方和接收方必须商定好密钥，然后使双方都能保存好密钥。某次如果一方的密钥被泄露，那么加密信息也就不安全

##### 非对称加密过程

1. A 和 B 分别在本地生成一个公钥和一个私钥
2. A 先拿到 B 的公钥
3. A 使用 B 的公钥编码生成密文，传输给 B
4. B 使用自己的私钥解锁

##### 非对称加密优缺点

优点：安全性更高，公钥是公开的，秘钥是自己保存的，不需要将秘钥给别人  
缺点：

- 加密和解密花费时间长、速度慢，只适合对少量数据进行加密
- 因为 B 的公钥是公开的，所以任何人都可用其公钥加密，伪装成 A 通信，解决办法是增加数字签名和证书

<br/>
<br/>

#### <a href="#14" id="14">14. 为什么 TCP 建立连接需要三次握手，而不是两次</a>

为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。

可以想象如下场景。客户端发送了一个连接请求 A ，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求 B。此时请求顺利到达服务端，服务端应答完就建立了请求，然后接受数据后释放了连接。

假设这时连接请求 A 在两端关闭后终于抵达了服务端，那么此时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 ESTABLISHED 状态。但是客户端其实是 CLOSED 的状态，那么就会导致服务端一直等待，造成资源的浪费。

PS：在建立连接中，任意一段掉线，TCP 都会重发 SYN 包，一般会重试五次，在建立连接中可能会遇到 SYN Flood 攻击。遇到这种情况可以选择调低重试次数或者干脆在不能处理的情况下拒绝请求。

<br/>
<br/>

#### <a href="#15" id="15">15. https 的握手过程</a>

1. 客户端发出 https 请求，请求服务端建立 SSL 连接

2. 服务端收到 https 请求，申请或自制数字证书，得到公钥和服务端私钥，并将公钥发送给客户端

3. 客户端验证公钥，不通过验证则发出警告，通过验证则产生一个随机的客户端私钥

4. 客户端将该随机生成的私钥与服务端公钥进行对称加密后传给服务端

5. 服务端收到加密内容后，通过服务端私钥进行非对称解密，得到客户端私钥

6. 服务端将客户端私钥和内容进行对称加密，并将加密内容发送给客户端

7. 客户端收到加密内容后，通过客户端私钥进行对称解密，得到内容

<br>
<br>

#### <a href="#16" id="16">16. CDN 是什么？描述下 CDN 原理？为什么要用 CDN?</a>

CDN 的全称是 Content Delivery Network，即 内容分发网络。

工作原理：将源码的资源缓存到位于全国各地的 CDN 节点上，用户请求资源时，就近返回节点上缓存的资源，而不需要每个用户的请求都回源站点获取，避免网络拥塞、分担源站压力，保证用户访问资源的速度和体验。

为什么要用 CDN

1. 为了加速网站的访问。
2. 为了实现跨运营商、跨地域的全网覆盖
3. 为了保障网站安全
4. 为了异地备源
5. 为了节约成本投入
6. 为了更专注业务本身

<br>
<br>

#### <a href="#17" id="17">17. 说一下正向代理和反向代理</a>

代理是在服务器和客户端之间假设的一层服务器，代理将接收客户端的请求并将它转发给服务器，然后将服务端的响应转发给客户端。

不管是正向代理还是反向代理，实现的都是上面的功能。

##### 正向代理（VPN）

> 正向代理，意思是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端。

**正向代理** 是为我们服务的，即为客户端服务，客户端可以根据正向代理访问到它本身无法访问到的服务器资源。

**正向代理** 是对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。

##### 反向代理（Nginx）

> 反向代理 方式是指以代理服务器来接受连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给客户端。

**反向代理** 是为服务端服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。

**反向代理** 对服务端是透明的，对客户端是非透明的，即客户端并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务。

参考 / 来源：

[公众号：code 秘密花园 - 前端开发者必备的 nginx 知识](https://mp.weixin.qq.com/s/vVg9mNA8EFuMnLCfweaFyA)

<br>
<br>
